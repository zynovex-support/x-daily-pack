{
  "name": "Slack Approvals - X Daily Pack",
  "nodes": [
    {
      "parameters": {},
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        200,
        300
      ],
      "id": "manual-trigger"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "*/1 * * * *"
            }
          ]
        }
      },
      "name": "Every Minute",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [
        200,
        460
      ],
      "id": "schedule-trigger"
    },
    {
      "parameters": {
        "jsCode": "// Slack Approval Processor (polling) for n8n\n// - Scans recent pack messages (by Block Kit header)\n// - Looks for commands like: post 1|2|3ï¼ˆæ”¯æŒçº¿ç¨‹å›žå¤ï¼Œä¹Ÿå®¹é”™é¢‘é“é¡¶å±‚å‘½ä»¤ï¼Œè‡ªåŠ¨å…³è”åˆ°æœ€è¿‘ä¸€æ¡ packï¼‰\n// - Replies in the thread with dry-run or posts to X via Rube MCP\n// - Idempotent via Slack ack marker (no workflow static data required)\n\nconst slackToken = $env.SLACK_BOT_TOKEN;\nconst channelId = $env.SLACK_CHANNEL_ID;\nconst xWriteEnabled = String($env.X_WRITE_ENABLED || '').toLowerCase() === 'true';\n\nconst rubeUrl = $env.RUBE_MCP_URL || 'https://rube.app/mcp';\nconst rubeToken = $env.RUBE_AUTH_TOKEN || $env.RUBE_API_TOKEN;\n\nconst maxThreads = Number.parseInt($env.SLACK_APPROVAL_MAX_THREADS || '10', 10);\nconst maxReplies = Number.parseInt($env.SLACK_APPROVAL_MAX_REPLIES || '200', 10);\nconst maxCommandAgeMinutes = Number.parseInt($env.SLACK_APPROVAL_MAX_AGE_MINUTES || '240', 10); // default 4h\n\nif (!slackToken) throw new Error('Missing SLACK_BOT_TOKEN');\nif (!channelId) throw new Error('Missing SLACK_CHANNEL_ID');\nif (xWriteEnabled && !rubeToken) throw new Error('Missing RUBE_AUTH_TOKEN (required when X_WRITE_ENABLED=true)');\n\nconst COMMAND_HELP = 'å¯ç”¨æŒ‡ä»¤ï¼š`post 1` / `post 2` / `post 3`ï¼ˆæŽ¨èåœ¨çº¿ç¨‹é‡Œå›žå¤ï¼›è‹¥å‘åœ¨é¢‘é“é¡¶å±‚ï¼Œä¼šè‡ªåŠ¨å…³è”åˆ°æœ€è¿‘ä¸€æ¡ packï¼‰';\nconst ACK_PREFIX = 'x_daily_pack_ack';\n\nconst normalizeText = (value) => String(value || '').trim();\nconst toNumberTs = (ts) => {\n  const num = Number.parseFloat(String(ts || '0'));\n  return Number.isFinite(num) ? num : 0;\n};\n\nconst slackApi = async (method, params) => {\n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `https://slack.com/api/${method}`,\n    headers: { Authorization: `Bearer ${slackToken}` },\n    qs: params\n  });\n\n  if (!response?.ok) {\n    const err = response?.error || 'unknown_error';\n    const needed = response?.needed ? ` (needed: ${response.needed})` : '';\n    const provided = response?.provided ? ` (provided: ${response.provided})` : '';\n    throw new Error(`Slack API ${method} failed: ${err}${needed}${provided}`);\n  }\n  return response;\n};\n\nconst slackPost = async (payload) => {\n  const response = await this.helpers.httpRequest({\n    method: 'POST',\n    url: 'https://slack.com/api/chat.postMessage',\n    headers: {\n      Authorization: `Bearer ${slackToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: payload\n  });\n\n  if (!response?.ok) {\n    const err = response?.error || 'unknown_error';\n    const needed = response?.needed ? ` (needed: ${response.needed})` : '';\n    const provided = response?.provided ? ` (provided: ${response.provided})` : '';\n    throw new Error(`Slack API chat.postMessage failed: ${err}${needed}${provided}`);\n  }\n  return response;\n};\n\nlet mcpProtocolVersion = '2025-06-18';\nlet mcpSessionId = null;\nlet requestId = 1;\n\nconst getHeader = (headers, name) => {\n  if (!headers) return null;\n  const key = Object.keys(headers).find(k => k.toLowerCase() === name.toLowerCase());\n  return key ? headers[key] : null;\n};\n\nconst parseSse = (text) => {\n  const lines = String(text || '').split('\\n');\n  for (let i = lines.length - 1; i >= 0; i -= 1) {\n    const line = lines[i].trim();\n    if (!line.startsWith('data:')) continue;\n    const payload = line.slice(5).trim();\n    if (!payload || payload === '[DONE]') continue;\n    try {\n      return JSON.parse(payload);\n    } catch (err) {\n      continue;\n    }\n  }\n  return null;\n};\n\nconst parseBody = (body) => {\n  if (!body) return null;\n  if (typeof body === 'string') {\n    const trimmed = body.trim();\n    if (trimmed.startsWith('{')) {\n      try {\n        return JSON.parse(trimmed);\n      } catch (err) {\n        return null;\n      }\n    }\n    return parseSse(trimmed);\n  }\n  return body;\n};\n\nconst mcpPost = async (payload, includeProtocolHeader = true) => {\n  const headers = {\n    Authorization: `Bearer ${rubeToken}`,\n    'Content-Type': 'application/json',\n    Accept: 'application/json, text/event-stream'\n  };\n  if (includeProtocolHeader && mcpProtocolVersion) headers['MCP-Protocol-Version'] = mcpProtocolVersion;\n  if (includeProtocolHeader && mcpSessionId) headers['Mcp-Session-Id'] = mcpSessionId;\n\n  const response = await this.helpers.httpRequest({\n    method: 'POST',\n    url: rubeUrl,\n    headers,\n    body: payload,\n    returnFullResponse: true\n  });\n\n  const rawBody = response?.body ?? response;\n  const parsedBody = parseBody(rawBody);\n  return {\n    body: parsedBody || rawBody,\n    headers: response?.headers\n  };\n};\n\nconst initializeMcp = async () => {\n  if (!xWriteEnabled) return;\n  const initPayload = {\n    jsonrpc: '2.0',\n    id: requestId++,\n    method: 'initialize',\n    params: {\n      protocolVersion: mcpProtocolVersion,\n      capabilities: {},\n      clientInfo: { name: 'n8n', version: '1.0.0' }\n    }\n  };\n\n  const initResponse = await mcpPost(initPayload, false);\n  const initResult = initResponse.body?.result;\n  if (initResult?.protocolVersion) {\n    mcpProtocolVersion = initResult.protocolVersion;\n  }\n\n  const sessionHeader = getHeader(initResponse.headers, 'mcp-session-id');\n  if (sessionHeader) {\n    mcpSessionId = Array.isArray(sessionHeader) ? sessionHeader[0] : sessionHeader;\n  }\n\n  await mcpPost({ jsonrpc: '2.0', method: 'notifications/initialized' }, true);\n};\n\nconst parseCommand = (text) => {\n  const normalized = normalizeText(text);\n  const m = normalized.match(/^(post|publish|å‘|å‘å¸ƒ)\\s*([123])\\b/i);\n  if (!m) return null;\n  return { type: 'post', option: Number(m[2]) };\n};\n\nconst extractAckTs = (text) => {\n  const match = String(text || '').match(/x_daily_pack_ack\\s+cmd_ts=([0-9.]+)/i);\n  return match?.[1] || null;\n};\n\nconst isDailyPackMessage = (msg) => {\n  const blocks = msg?.blocks;\n  if (!Array.isArray(blocks) || blocks.length === 0) return false;\n  const headerBlock = blocks.find((b) => b?.type === 'header');\n  const text = headerBlock?.text?.text || headerBlock?.text?.plain_text || '';\n  return String(text).includes(\"Today's X Daily Pack\");\n};\n\nconst extractDraftsFromBlocks = (blocks) => {\n  const drafts = {};\n\n  const extractFromSection = (sectionText) => {\n    if (!sectionText) return '';\n    const firstNewline = sectionText.indexOf('\\n');\n    const rest = firstNewline >= 0 ? sectionText.slice(firstNewline + 1) : sectionText;\n    const marker = '\\n\\n_å­—ç¬¦æ•°';\n    const markerIndex = rest.indexOf(marker);\n    const tweetText = markerIndex >= 0 ? rest.slice(0, markerIndex) : rest;\n    return tweetText.trim();\n  };\n\n  (blocks || []).forEach((block) => {\n    if (block?.type !== 'section') return;\n    const text = block?.text?.text;\n    if (!text || typeof text !== 'string') return;\n    if (text.includes('*Option 1:')) drafts[1] = extractFromSection(text);\n    if (text.includes('*Option 2:')) drafts[2] = extractFromSection(text);\n    if (text.includes('*Option 3:')) drafts[3] = extractFromSection(text);\n  });\n\n  return drafts;\n};\n\nconst postTweet = async (text) => {\n  const payload = {\n    jsonrpc: '2.0',\n    id: requestId++,\n    method: 'tools/call',\n    params: {\n      name: 'RUBE_MULTI_EXECUTE_TOOL',\n      arguments: {\n        tools: [\n          {\n            tool_slug: 'TWITTER_CREATION_OF_A_POST',\n            arguments: { text }\n          }\n        ]\n      }\n    }\n  };\n\n  const response = await mcpPost(payload, true);\n  const root = response.body?.result || response.body;\n\n  const tryExtractId = (obj) => {\n    if (!obj || typeof obj !== 'object') return null;\n    if (obj.id) return obj.id;\n    if (obj.data?.id) return obj.data.id;\n    if (obj.data?.data?.id) return obj.data.data.id;\n    if (Array.isArray(obj.results)) {\n      for (const r of obj.results) {\n        const id = tryExtractId(r?.response);\n        if (id) return id;\n      }\n    }\n    return null;\n  };\n\n  const content = root?.content;\n  if (Array.isArray(content)) {\n    const textEntry = content.find((entry) => entry?.type === 'text' && entry?.text);\n    if (textEntry?.text) {\n      try {\n        const parsed = JSON.parse(textEntry.text);\n        const id = tryExtractId(parsed);\n        if (id) return { data: { data: { id } }, raw: parsed };\n        return parsed;\n      } catch (err) {\n        return { raw: textEntry.text };\n      }\n    }\n  }\n  const id = tryExtractId(root);\n  if (id) return { data: { data: { id } }, raw: root };\n  return root;\n};\n\ntry {\n  const history = await slackApi('conversations.history', {\n    channel: channelId,\n    limit: 50,\n  });\n\n  console.log('Approvals: history messages', history.messages?.length || 0);\n\n  const historyMessages = history.messages || [];\n  const debug = {\n    history_count: historyMessages.length,\n    pack_roots: [],\n    channel_commands: [],\n    threads: []\n  };\n  const nowMs = Date.now();\n  const isFresh = (ts) => {\n    if (!maxCommandAgeMinutes || maxCommandAgeMinutes <= 0) return true;\n    const ageMs = nowMs - toNumberTs(ts) * 1000;\n    return ageMs >= 0 && ageMs <= maxCommandAgeMinutes * 60 * 1000;\n  };\n\n  const packRoots = historyMessages\n    .filter((msg) => isDailyPackMessage(msg))\n    .filter((msg) => !msg.thread_ts || msg.thread_ts === msg.ts)\n    .slice(0, Math.max(1, Math.min(maxThreads, 50)));\n\n  console.log('Approvals: packRoots', packRoots.length);\n\n  debug.pack_roots = packRoots.map((msg) => ({\n    ts: msg.ts,\n    thread_ts: msg.thread_ts,\n    has_header: isDailyPackMessage(msg),\n    text: normalizeText(msg.text || '').slice(0, 120)\n  }));\n\n  if (!packRoots.length) return [];\n\n  // sort roots for mapping top-level commands -> nearest preceding pack\n  const packRootsAsc = [...packRoots].sort((a, b) => toNumberTs(a.ts) - toNumberTs(b.ts));\n\n  // channel-level commands (non-thread); map to nearest preceding pack root\n  const channelCommands = historyMessages\n    .filter((msg) => !msg.thread_ts && !msg.bot_id && !msg.subtype && msg.user)\n    .filter((msg) => isFresh(msg.ts))\n    .map((msg) => ({ msg, cmd: parseCommand(msg.text) }))\n    .filter((entry) => entry.cmd)\n    .map((entry) => {\n      const cmdTs = toNumberTs(entry.msg.ts);\n      let targetRoot = null;\n      for (const root of packRootsAsc) {\n        if (cmdTs >= toNumberTs(root.ts)) targetRoot = root;\n      }\n      return { ...entry, targetThreadTs: targetRoot?.ts || null };\n    })\n    .filter((entry) => entry.targetThreadTs);\n\n  console.log('Approvals: channel-level commands', channelCommands.length);\n\n  debug.channel_commands = channelCommands.map((entry) => ({\n    ts: entry.msg?.ts,\n    text: normalizeText(entry.msg?.text || '').slice(0, 120),\n    targetThreadTs: entry.targetThreadTs\n  }));\n\n  await initializeMcp();\n\n  const optionMap = { 1: 'hot_take', 2: 'framework', 3: 'case' };\n  const results = [];\n  const debugThreads = [];\n\n  for (const root of packRoots) {\n    const threadTs = root?.ts;\n    if (!threadTs) continue;\n\n    const drafts = extractDraftsFromBlocks(root.blocks);\n    if (!drafts[1] && !drafts[2] && !drafts[3]) continue;\n\n    const replies = await slackApi('conversations.replies', {\n      channel: channelId,\n      ts: threadTs,\n      limit: Math.max(20, Math.min(maxReplies, 200)),\n    });\n\n    console.log('Approvals: thread replies', replies.messages?.length || 0, 'thread', threadTs);\n\n    const messages = replies.messages || [];\n\n    const acked = new Set();\n    for (const msg of messages) {\n      if (!msg?.bot_id) continue;\n      const text = msg.text || '';\n      const ackTs = extractAckTs(text);\n      if (!ackTs) continue;\n      const hasFinalMarker = /âœ…|ðŸ§ª|âŒ|æŽ¨æ–‡å‘å¸ƒæˆåŠŸ|å·²å‘å¸ƒ Option|æ‰§è¡Œå¤±è´¥|Dry-run|dry-run/i.test(text);\n      if (hasFinalMarker) acked.add(ackTs);\n    }\n\n    const threadDebug = {\n      thread_ts: threadTs,\n      drafts: Object.keys(drafts || {}).filter((k) => drafts[k]),\n      replies_count: messages.length,\n      acked: Array.from(acked),\n      cmds: [],\n      processed: []\n    };\n    debugThreads.push(threadDebug);\n\n    // collect thread commands + mapped channel commands\n    const cmdsToProcess = [];\n    for (const msg of messages) {\n      if (!msg?.ts) continue;\n      if (msg.ts === threadTs) continue; // root\n      if (msg.subtype || msg.bot_id) continue;\n      if (!msg.user) continue;\n      if (!isFresh(msg.ts)) continue;\n      cmdsToProcess.push({ msg, cmd: parseCommand(msg.text), source: 'thread' });\n    }\n    for (const entry of channelCommands) {\n      if (entry.targetThreadTs !== threadTs) continue;\n      cmdsToProcess.push({ msg: entry.msg, cmd: entry.cmd, source: 'channel' });\n    }\n\n    threadDebug.cmds = cmdsToProcess\n      .filter((entry) => entry.cmd)\n      .map((entry) => ({\n        ts: entry.msg?.ts,\n        source: entry.source,\n        option: entry.cmd?.option,\n        text: normalizeText(entry.msg?.text || '').slice(0, 120)\n      }));\n\n    const seenCmdTs = new Set(); // guard against accidental duplicates within same run\n\n    for (const entry of cmdsToProcess) {\n      const msg = entry.msg;\n      const cmd = entry.cmd;\n      if (!msg?.ts || !cmd) continue;\n      if (acked.has(msg.ts)) {\n        threadDebug.processed.push({ ts: msg.ts, option: cmd.option, status: 'skipped_ack' });\n        continue;\n      }\n      if (seenCmdTs.has(msg.ts)) {\n        threadDebug.processed.push({ ts: msg.ts, option: cmd.option, status: 'skipped_seen' });\n        continue;\n      }\n      seenCmdTs.add(msg.ts);\n\n      const tweetText = drafts[cmd.option] || '';\n      const ackMarker = `\\n\\n_(${ACK_PREFIX} cmd_ts=${msg.ts})_`;\n\n      const sendResponse = async (text) => {\n        await slackPost({\n          channel: channelId,\n          thread_ts: threadTs,\n          text\n        });\n        if (entry.source === \"channel\" && msg.ts !== threadTs) {\n          await slackPost({\n            channel: channelId,\n            thread_ts: msg.ts,\n            text\n          });\n        }\n      };\n\n      try {\n        if (!tweetText) {\n          await sendResponse(`æ‰¾ä¸åˆ° Option ${cmd.option} çš„è‰ç¨¿å†…å®¹ã€‚${COMMAND_HELP}${ackMarker}`);\n          results.push({ json: { status: 'missing_draft', command_ts: msg.ts, thread_ts: threadTs, option: cmd.option } });\n          threadDebug.processed.push({ ts: msg.ts, option: cmd.option, status: 'missing_draft' });\n          continue;\n        }\n\n\n        // Ack immediately so the user sees the command is being processed\n        await sendResponse(`ðŸ“¥ å·²æ”¶åˆ° post ${cmd.option}ï¼Œæ­£åœ¨å¤„ç†...`);\n\n        console.log('Approvals: acked command', cmd.option, 'thread', threadTs);\n\n        if (!xWriteEnabled) {\n          await sendResponse(`ðŸ§ª Dry-runï¼šå°†å‘å¸ƒ Option ${cmd.option}\\n\\n${tweetText}\\n\\nå¦‚éœ€çœŸæ­£å‘å¸ƒï¼Œè¯·åœ¨çŽ¯å¢ƒå˜é‡è®¾ç½® X_WRITE_ENABLED=true å¹¶é‡å¯ n8nã€‚${ackMarker}`);\n          results.push({ json: { status: 'dry_run', command_ts: msg.ts, thread_ts: threadTs, option: cmd.option } });\n          threadDebug.processed.push({ ts: msg.ts, option: cmd.option, status: 'dry_run' });\n          continue;\n        }\n\n        const postResult = await postTweet(tweetText);\n        console.log('Approvals: postResult received');\n\n        const isFailure = postResult?.successful === false || postResult?.error;\n        if (isFailure) {\n          const msg = postResult?.error || 'Tweet tool returned unsuccessful';\n          throw new Error(msg);\n        }\n\n        // Extract tweet ID and construct URL (robust scan)\n        const tryExtractId = (obj) => {\n          if (!obj || typeof obj !== 'object') return null;\n          if (obj.id) return obj.id;\n          if (obj.data?.id) return obj.data.id;\n          if (obj.data?.data?.id) return obj.data.data.id;\n          if (Array.isArray(obj.edit_history_tweet_ids) && obj.edit_history_tweet_ids.length) return obj.edit_history_tweet_ids[0];\n          if (Array.isArray(obj.results)) {\n            for (const r of obj.results) {\n              const id = tryExtractId(r?.response);\n              if (id) return id;\n            }\n          }\n          if (Array.isArray(obj.content)) {\n            for (const c of obj.content) {\n              try {\n                const parsed = JSON.parse(c?.text || '{}');\n                const id = tryExtractId(parsed);\n                if (id) return id;\n              } catch (_) { /* ignore */ }\n            }\n          }\n          return null;\n        };\n\n        let tweetId = tryExtractId(postResult) || tryExtractId(postResult?.data) || tryExtractId(postResult?.data?.data);\n        const tweetUrl = tweetId ? `https://x.com/i/web/status/${tweetId}` : '';\n\n        const successMessage = tweetUrl\n          ? `âœ… æŽ¨æ–‡å‘å¸ƒæˆåŠŸ\\nðŸ”— ${tweetUrl}${ackMarker}`\n          : `âœ… æŽ¨æ–‡å‘å¸ƒæˆåŠŸï¼Œä½†æœªèƒ½è§£æžé“¾æŽ¥${ackMarker}`;\n\n        await sendResponse(successMessage);\n        console.log('Approvals: success message sent', cmd.option, 'url', tweetUrl || 'none');\n\n        results.push({ json: { status: 'posted', command_ts: msg.ts, thread_ts: threadTs, option: cmd.option } });\n        threadDebug.processed.push({ ts: msg.ts, option: cmd.option, status: 'posted', tweet_url: tweetUrl || '' });\n      } catch (err) {\n        await sendResponse(`âŒ æ‰§è¡Œå¤±è´¥ï¼š${err.message}\\n${COMMAND_HELP}${ackMarker}`);\n        results.push({ json: { status: 'failed', command_ts: msg.ts, thread_ts: threadTs, option: cmd.option, error: err.message } });\n        threadDebug.processed.push({ ts: msg.ts, option: cmd.option, status: 'failed', error: err.message });\n      }\n    }\n  }\n\n  debug.threads = debugThreads;\n  if (!results.length) {\n    results.push({ json: { status: 'noop', debug } });\n  } else {\n    results.push({ json: { status: 'debug', debug } });\n  }\n\n  return results;\n} catch (error) {\n  throw new Error(`Slack approval poller failed: ${error.message}`);\n}\n"
      },
      "name": "Process Slack Commands",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        520,
        380
      ],
      "id": "process"
    },
    {
      "parameters": {
        "jsCode": "// Feedback Recorder - è®°å½•ç”¨æˆ·å®¡æ‰¹è¡Œä¸º\nconst items = $input.all();\nconst DEBUG = $env.FEEDBACK_DEBUG === 'true';\nconst ENABLED = $env.FEEDBACK_LEARNING_ENABLED !== 'false';\n\nif (!ENABLED) { console.log('[FeedbackRecorder] Disabled'); return items; }\n\nlet storage;\ntry {\n  storage = this.getWorkflowStaticData ? this.getWorkflowStaticData('global') : this.helpers?.getWorkflowStaticData?.call(this, 'global');\n} catch (err) { console.log('[FeedbackRecorder] Cannot access staticData'); return items; }\n\nif (!storage) { return items; }\nif (!storage.feedbackHistory) storage.feedbackHistory = [];\nif (!storage.learnedWeights) storage.learnedWeights = { version: 1, updated_at: null, categoryBoosts: {}, sourceBoosts: {} };\n\nconst MAX_HISTORY = 500;\nconst EXPIRY_DAYS = 30;\nconst now = Date.now();\nconst expiryMs = EXPIRY_DAYS * 24 * 60 * 60 * 1000;\nstorage.feedbackHistory = storage.feedbackHistory.filter(f => (now - f.timestamp) < expiryMs);\n\nlet recorded = 0;\nfor (const item of items) {\n  const data = item.json || {};\n  if (!data.status || data.status === 'noop' || data.status === 'debug') continue;\n  let action = null;\n  if (data.status === 'posted' || data.status === 'dry_run') action = 'approved';\n  else if (data.status === 'skipped_ack' || data.status === 'skipped_seen') continue;\n  if (!action) continue;\n  const feedback = {\n    feedbackId: `fb_${now.toString(36)}_${Math.random().toString(36).slice(2, 6)}`,\n    timestamp: now,\n    userId: data.user_id || 'unknown',\n    action: action,\n    tweetOption: data.option || null,\n    threadTs: data.thread_ts || null,\n    commandTs: data.command_ts || null,\n    sourceArticles: []\n  };\n  storage.feedbackHistory.push(feedback);\n  recorded++;\n  if (DEBUG) console.log(`[FeedbackRecorder] Recorded: ${action} option=${data.option}`);\n}\n\nif (storage.feedbackHistory.length > MAX_HISTORY) storage.feedbackHistory = storage.feedbackHistory.slice(-MAX_HISTORY);\nconsole.log(`[FeedbackRecorder] Recorded ${recorded}, total ${storage.feedbackHistory.length}`);\nreturn items;\n"
      },
      "name": "Record Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        760,
        380
      ],
      "id": "feedback-recorder"
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Process Slack Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Every Minute": {
      "main": [
        [
          {
            "node": "Process Slack Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Slack Commands": {
      "main": [
        [
          {
            "node": "Record Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 2
}